코드 파서가 함수 선언 후에 내부 코드 읽을때 걍 세미콜론 나올때까지 버퍼에 쭉 토큰 밀어넣었다가
대강 구조 분석하고 적절한 핸들러 함수로 처리하면 야무지겠는데?

아 에러 시스템이 get()이나 consume()후에 에러 발생하면 return Node{}, err 한거를 그대~~로 받아가지고 Node{}의 Begin과 End를 받아서
에러 메시지 띄우네.. 버그 픽스 "해줘"

토큰의 끝에 EOF 토큰을 배치해서 advance가 맨 마지막 토큰
int main() {

} <- 이런거
처리 못하는 오류를 해결하자!
루프는 lexer.cur().Type == tok.EOF 이런식으로 감지하면 되겠네

변수가 쓸모없네? 각 커맨드 함수에 변수 지원 기능을 넣어줘야 함.

목록:
Tp(), Setblock(), Summon() ; 이 세 놈은 '위치' 시스템 자체에 변수 지원을 넣어야겠네.
Data.Modify()
Tellraw()
Damage()
Effect.Give()

직접 매크로 넣어야 하는건 변수 지원이라고 하기엔 애매하죠? ㅇㅇ,,

스택 메모리 주소는 양수, 힙 메모리 주소는 음수임.
[12]는 stack의 12번째 값,
[-12]는 heap의 12번째 값.

메모리 시스템 변경할거임.

1. stackptr, baseptr 이제 스코어 아님. 마커로 대체.

이제 메모리는 주소가 없음!! 오로지 순서만 있을뿐.. -> 포인터 구현을 위해 나중에 추가 할지도..
push하면 마커 소환->마지막에 소환된 마커에 ride->stackptr마커ride->함수 시작이라면 baseptr마커ride

stack 자료 구조:
마커->baseptr,마커->마커->마커->stackptr

a->b는 b가 a를 타고있다는 뜻 a->b,c는 b와 c가 a를 타고있다는 뜻
baseptr와 stackptr는 그 마커가 타고있는 마커를 가리키는 것임.
a->stackptr,b 하면 b가 아니라 a를 가리키는 거.

함수 실행되면 스택 push,
종료되면 스택 pop 만듦.
이제 다른 변수 시스템도 바뀐 구조에 맞게 코딩하셈.

> 했음 ㅅㄱ

표현식 문법 구상 뻘글:
expr->string
expr->int
expr->selector
expr->func()
expr->expr+expr

expr

오케이! 일단 +가 작동하게 만들었으!
이제 -랑 *랑 /를 만들면 되는데..
*랑 /가 우선적으로 되어야 하잖아?
그래서 내가 생각한 알고리즘은 *와 /를 처리하는
단계랑 +랑 -를 처리하는 단계를 나누는 거야.

3+5*6
이런 수식에서 우선 *를 먼저 Expr으로 치환해.
3+Expr
그 다음에 *나 /가 있는지 확인하고, 없으면 +와 - 단계로 넘어가!
그러면 이제 +와 -를 Expr으로 치환.
Expr
끗!

Lexer는 이렇게 마무리 하고.. 그 다음에 다시 Lexer에 맞춰서 AstParser 개발 ㄱㄱ
-> 아 맞다 함수랑 변수가 있었지.. 그리고 표현식 만든거 로직을 인자 받는 곳에도 넣어야 함
-> 슈ㅜ바 수식에 괄호 넣을 수 있었지?? 이런!!!
->a=0 이런것도 있음

걍 이항 연산 뺼까..
쳇.. 투표 결과, 추가 해야된다..

생각보다 빠르게 완료. ; 경험이 있어서 그런가;;

타입 체커를 추가할거임.
-> 끗

이항 연산자를 AstParser에 구현 중.
>아마도 다함. 제발!

RAWLINE 구현 함.

해야될거:
-MethodSet(or Class) 구현
-Heap 메모리 구현
-메모리 시스템 개선(할 수 있으면)
-제어 구문들 구현(if,else,for,while 등등)
-#include 등 구현(네이티브 데이터팩 include 가능해야함)
-배열 자료형 구현(이거 하려면 포인터 비스무리한거 있어야 하네;;)
--> 배열을 위해 모든 bit들이 다시 bitAddr를 가지게 해야겠군..
-포인터 넣을까 말까 고민
아 뭐부터 하지

않이;; 마커는 ride가 안되네? interaction으로 바꿈 근데 cut이나 ret가 제대로 작동 안 함;;
"해줘"
아 뭐야 버그가 아니러 아직 안 지운 인터렉션 남아있는 거였네;;

그럼 이제 뭐하지? #include ㄱㄱ
자 그러면 계획을 세워보자..
우선 #include "something.fl" 이런식으로 해두면 그 자리에
something.fl 그대로 갖다 박으면 되겠지?
-> 일단 이건 완성. 근데 이제 네이티브 데팩은 어케하지 ㅋㅋ

.mcfunction 파일들을 .zip으로 묶고 .flib으로 바꿔서
flow.exe가 있는곳에 있는 libs 디렉토리에 넣어두면 -l 플래그로
컴파일 시 포함 가능하게 했음.(아직 포함은 안되고 .flib파일 인식만 함)

알아내야 할게 하나 있음:
zip.OpenReader(...)하고나서 reader.File을 읽을때 이게
하위 디렉토리에 있는 파일도 포함하는 배열인지 확인해야 함.
굳이 디렉토리 발견했을때 다시 열 필요 없는지 확인해야 한다는 뜻.
-> 다시 열 필요 없다! 나이스!!

#include와 linker 완성!

이제 뭐 만들지?
제어구문 구현 ㄱㄱ
우선 if부터.. 익명 함수가 있어야겠군!
아 조건을 어떤 식으로 하지? &&나||도 있어야 하나?
if predicate 같은 것도 구현해야하나?

아 셀렉터 개념을 명확히 해야함.

휴..
as @s {
	...
}
이런식으로 할거임

if문은 굳이 코딩하듯이 하지 않고 기존 execute처럼 사용할거임
if score @s obj matches 1.. {
	// do something
}
이런 느낌

원래는 .TODO였는데, 지금보니 NOTE에 가까워서 이름 바꿈.

tokenizer에 IF토큰 추가, '=='도 OPERATOR 토큰으로 처리했고,
lexer에 ifStatement 추가함.
ast parser에 ifStatement 추가했고, TODO 남겨놓음.
